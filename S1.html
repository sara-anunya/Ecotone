import python

#!/usr/bin/env python3
"""
Point Cloud Web Viewer Generator
Converts point cloud files into interactive 3D web viewers with Rhino-like navigation
Supports: PLY, XYZ, PCD, LAS, TXT formats
"""

import numpy as np
import json
import os
import sys

def read_ply(filepath):
    """Read PLY format point cloud"""
    points = []
    colors = []
    header_end = False
    vertex_count = 0
    has_color = False
    
    with open(filepath, 'rb') as f:
        for line in f:
            line = line.decode('utf-8').strip()
            if line.startswith('element vertex'):
                vertex_count = int(line.split()[-1])
            if 'property uchar red' in line or 'property float red' in line:
                has_color = True
            if line == 'end_header':
                header_end = True
                break
        
        if header_end:
            for _ in range(vertex_count):
                line = f.readline().decode('utf-8').strip().split()
                if len(line) >= 3:
                    points.append([float(line[0]), float(line[1]), float(line[2])])
                    if has_color and len(line) >= 6:
                        colors.append([float(line[3])/255, float(line[4])/255, float(line[5])/255])
    
    return np.array(points), np.array(colors) if colors else None

def read_xyz(filepath):
    """Read XYZ format point cloud (x y z [r g b])"""
    data = np.loadtxt(filepath)
    if data.shape[1] >= 3:
        points = data[:, :3]
        colors = data[:, 3:6] / 255.0 if data.shape[1] >= 6 else None
        return points, colors
    return None, None

def read_txt(filepath):
    """Read TXT format point cloud"""
    return read_xyz(filepath)

def read_pcd(filepath):
    """Read PCD format point cloud"""
    points = []
    colors = []
    data_start = False
    has_rgb = False
    
    with open(filepath, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('FIELDS'):
                if 'rgb' in line.lower():
                    has_rgb = True
            if line.startswith('DATA'):
                data_start = True
                continue
            if data_start and line:
                parts = line.split()
                if len(parts) >= 3:
                    points.append([float(parts[0]), float(parts[1]), float(parts[2])])
                    if has_rgb and len(parts) >= 4:
                        # Simple RGB extraction (this may need adjustment based on PCD format)
                        colors.append([1.0, 1.0, 1.0])  # Default white if RGB parsing is complex
    
    return np.array(points), np.array(colors) if colors else None

def read_las(filepath):
    """Read LAS format point cloud (requires laspy)"""
    try:
        import laspy
        las = laspy.read(filepath)
        points = np.vstack((las.x, las.y, las.z)).T
        
        # Try to get colors if available
        colors = None
        if hasattr(las, 'red'):
            colors = np.vstack((las.red, las.green, las.blue)).T / 65535.0
        
        return points, colors
    except ImportError:
        print("Warning: laspy not installed. Install with: pip install laspy")
        return None, None

def load_pointcloud(filepath):
    """Load point cloud based on file extension"""
    ext = os.path.splitext(filepath)[1].lower()
    
    if ext == '.ply':
        return read_ply(filepath)
    elif ext == '.xyz':
        return read_xyz(filepath)
    elif ext == '.txt':
        return read_txt(filepath)
    elif ext == '.pcd':
        return read_pcd(filepath)
    elif ext == '.las':
        return read_las(filepath)
    else:
        print(f"Unsupported file format: {ext}")
        return None, None

def downsample_pointcloud(points, colors, max_points=100000):
    """Downsample point cloud if it's too large"""
    if len(points) <= max_points:
        return points, colors
    
    indices = np.random.choice(len(points), max_points, replace=False)
    downsampled_points = points[indices]
    downsampled_colors = colors[indices] if colors is not None else None
    
    print(f"Downsampled from {len(points)} to {max_points} points for web performance")
    return downsampled_points, downsampled_colors

def generate_html_viewer(points, colors, output_path):
    """Generate an interactive HTML viewer with Rhino-like controls"""
    
    # Convert points to JSON
    points_list = points.tolist()
    colors_list = colors.tolist() if colors is not None else None
    
    # Calculate bounding box for camera positioning
    min_bounds = points.min(axis=0)
    max_bounds = points.max(axis=0)
    center = (min_bounds + max_bounds) / 2
    size = np.linalg.norm(max_bounds - min_bounds)
    
    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BMT Point Cloud Viewer</title>
    <style>
        body {{
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }}
        #container {{
            width: 100vw;
            height: 100vh;
        }}
        #info {{
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 250px;
        }}
        #controls {{
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
        }}
        .control-item {{
            margin: 5px 0;
        }}
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>BMT Point Cloud Viewer</strong><br>
        Points: {len(points):,}<br>
        <span id="fps">FPS: --</span>
    </div>
    <div id="controls">
        <div class="control-item"><strong>Rhino-like Controls:</strong></div>
        <div class="control-item">üñ±Ô∏è Right-click + Drag: Rotate</div>
        <div class="control-item">üñ±Ô∏è Middle-click + Drag: Pan</div>
        <div class="control-item">üñ±Ô∏è Scroll: Zoom</div>
        <div class="control-item">üñ±Ô∏è Shift + Right-click: Pan</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Point cloud data
        const pointsData = {json.dumps(points_list)};
        const colorsData = {json.dumps(colors_list) if colors_list else 'null'};
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            {size * 10}
        );
        camera.position.set({center[0] + size}, {center[1] + size}, {center[2] + size});
        camera.lookAt({center[0]}, {center[1]}, {center[2]});
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({{ antialias: true }});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Create point cloud
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(pointsData.flat());
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // Add colors if available
        if (colorsData) {{
            const colors = new Float32Array(colorsData.flat());
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }}
        
        const material = new THREE.PointsMaterial({{
            size: {size / 500},
            vertexColors: colorsData ? true : false,
            color: colorsData ? 0xffffff : 0x00aaff
        }});
        
        const pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper({size * 2}, 20, 0x444444, 0x222222);
        gridHelper.position.y = {min_bounds[1]};
        scene.add(gridHelper);
        
        // Add axis helper
        const axesHelper = new THREE.AxesHelper({size / 2});
        axesHelper.position.set({center[0]}, {center[1]}, {center[2]});
        scene.add(axesHelper);
        
        // Rhino-like controls implementation
        let isRotating = false;
        let isPanning = false;
        let previousMousePosition = {{ x: 0, y: 0 }};
        const target = new THREE.Vector3({center[0]}, {center[1]}, {center[2]});
        
        renderer.domElement.addEventListener('mousedown', (e) => {{
            if (e.button === 2 || (e.button === 0 && e.shiftKey)) {{ // Right-click or Shift+Left
                if (e.shiftKey) {{
                    isPanning = true;
                }} else {{
                    isRotating = true;
                }}
                e.preventDefault();
            }} else if (e.button === 1) {{ // Middle-click
                isPanning = true;
                e.preventDefault();
            }}
            previousMousePosition = {{ x: e.clientX, y: e.clientY }};
        }});
        
        renderer.domElement.addEventListener('mousemove', (e) => {{
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            if (isRotating) {{
                // Rotate around target
                const offset = new THREE.Vector3().subVectors(camera.position, target);
                const spherical = new THREE.Spherical().setFromVector3(offset);
                
                spherical.theta -= deltaX * 0.01;
                spherical.phi -= deltaY * 0.01;
                spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
                
                offset.setFromSpherical(spherical);
                camera.position.copy(target).add(offset);
                camera.lookAt(target);
            }} else if (isPanning) {{
                // Pan camera
                const distance = camera.position.distanceTo(target);
                const panSpeed = distance * 0.001;
                
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(0, 1, 0);
                camera.getWorldDirection(right);
                right.cross(up).normalize();
                
                camera.position.addScaledVector(right, -deltaX * panSpeed);
                camera.position.addScaledVector(up, deltaY * panSpeed);
                target.addScaledVector(right, -deltaX * panSpeed);
                target.addScaledVector(up, deltaY * panSpeed);
            }}
            
            previousMousePosition = {{ x: e.clientX, y: e.clientY }};
        }});
        
        renderer.domElement.addEventListener('mouseup', () => {{
            isRotating = false;
            isPanning = false;
        }});
        
        // Disable context menu
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {{
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = new THREE.Vector3().subVectors(camera.position, target).normalize();
            const distance = camera.position.distanceTo(target);
            
            if (e.deltaY > 0) {{
                camera.position.addScaledVector(direction, distance * zoomSpeed);
            }} else {{
                camera.position.addScaledVector(direction, -distance * zoomSpeed);
            }}
        }});
        
        // Handle window resize
        window.addEventListener('resize', () => {{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }});
        
        // FPS counter
        let lastTime = performance.now();
        let frames = 0;
        
        // Animation loop
        function animate() {{
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            
            // Update FPS
            frames++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {{
                document.getElementById('fps').textContent = `FPS: ${{frames}}`;
                frames = 0;
                lastTime = currentTime;
            }}
        }}
        
        animate();
    </script>
</body>
</html>"""
    
    with open(output_path, 'w') as f:
        f.write(html_content)
    
    print(f"HTML viewer generated: {output_path}")

def main():
    # Configuration
    input_file = "ASSETS/BMT_Pointcloud"  # Placeholder - will detect extension
    output_file = "/mnt/user-data/outputs/pointcloud_viewer.html"
    max_points = 100000  # Adjust for performance
    
    # Try to find the file with common extensions
    possible_extensions = ['.ply', '.xyz', '.txt', '.pcd', '.las', '']
    found_file = None
    
    for ext in possible_extensions:
        test_path = input_file + ext
        if os.path.exists(test_path):
            found_file = test_path
            break
    
    if not found_file:
        print(f"Error: Could not find point cloud file.")
        print(f"Looking for: {input_file}[.ply|.xyz|.txt|.pcd|.las]")
        print(f"\nUsage: python pointcloud_viewer.py [input_file] [output_file]")
        sys.exit(1)
    
    # Allow command line arguments
    if len(sys.argv) > 1:
        found_file = sys.argv[1]
    if len(sys.argv) > 2:
        output_file = sys.argv[2]
    
    print(f"Loading point cloud from: {found_file}")
    points, colors = load_pointcloud(found_file)
    
    if points is None:
        print("Error: Failed to load point cloud")
        sys.exit(1)
    
    print(f"Loaded {len(points)} points")
    
    # Downsample if necessary
    points, colors = downsample_pointcloud(points, colors, max_points)
    
    # Generate HTML viewer
    generate_html_viewer(points, colors, output_file)
    
    print(f"\nViewer ready! Open the file in your browser:")
    print(f"  {output_file}")

if __name__ == "__main__":
    main()