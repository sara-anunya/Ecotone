<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAS Point Cloud Viewer - Rhino Controls</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Darker+Grotesque:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Darker Grotesque', sans-serif;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
        }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            z-index: 1000;
        }
        #error {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff6b6b;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            max-width: 500px;
            display: none;
            z-index: 1001;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.6;
        }
        #controls-info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            line-height: 1.8;
        }
        .control-key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="loading">Loading point cloud...</div>
    <div id="error"></div>
    <div id="info"></div>
    <div id="controls-info">
        <strong>Rhino-Style Controls:</strong><br>
        <span class="control-key">Left Click + Drag</span> Rotate<br>
        <span class="control-key">Right Click + Drag</span> Pan<br>
        <span class="control-key">Middle Mouse / Scroll</span> Zoom<br>
        <span class="control-key">Shift + Right Click</span> Zoom to Region
    </div>
    
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls configured for Rhino-style interaction
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false; // False for more Rhino-like behavior
        controls.minDistance = 1;
        controls.maxDistance = 50000;
        
        // Configure mouse buttons for Rhino-style controls
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,    // Left button to rotate
            MIDDLE: THREE.MOUSE.DOLLY,   // Middle button to zoom
            RIGHT: THREE.MOUSE.PAN       // Right button to pan
        };

        // Add grid helper for reference
        const gridHelper = new THREE.GridHelper(1000, 50, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Add axes helper
        const axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Helper function to show errors
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            console.error(message);
        }

        // LAS Parser
        async function loadLASFile(filepath) {
            try {
                document.getElementById('loading').textContent = 'Fetching LAS file...';
                console.log('Attempting to load:', filepath);
                
                const response = await fetch(filepath);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - Check file path and file existence`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log('File loaded, size:', arrayBuffer.byteLength, 'bytes');
                
                document.getElementById('loading').textContent = 'Parsing LAS data...';
                
                // Parse LAS file
                const lasData = parseLAS(arrayBuffer);
                
                console.log('Parsed points:', lasData.positions.length / 3);
                console.log('Has colors:', lasData.colors.length > 0);
                
                document.getElementById('loading').textContent = 'Creating point cloud...';
                
                // Create Three.js geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(lasData.positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(lasData.colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3.0, // Visible point size
                    vertexColors: true,
                    sizeAttenuation: true
                });
                
                const pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);
                
                // Center camera on the point cloud
                geometry.computeBoundingSphere();
                geometry.computeBoundingBox();
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius;
                const bbox = geometry.boundingBox;
                
                console.log('Bounding sphere center:', center);
                console.log('Bounding sphere radius:', radius);
                console.log('Bounding box:', bbox);
                
                // Position camera for good initial view
                camera.position.set(center.x + radius, center.y + radius, center.z + radius);
                controls.target.copy(center);
                controls.update();
                
                // Update grid size based on point cloud
                gridHelper.scale.set(radius / 500, 1, radius / 500);
                gridHelper.position.copy(center);
                gridHelper.position.y = bbox.min.y;
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('info').innerHTML = `
                    <strong>Point Cloud Info:</strong><br>
                    Points: ${(lasData.positions.length / 3).toLocaleString()}<br>
                    Bounds: ${bbox.max.x - bbox.min.x} × ${bbox.max.y - bbox.min.y} × ${bbox.max.z - bbox.min.z} units<br>
                    Center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})
                `;
                
                console.log('Point cloud loaded successfully!');
                
            } catch (error) {
                console.error('Error loading LAS file:', error);
                showError(`Error: ${error.message}`);
                document.getElementById('loading').textContent = 'Failed to load';
            }
        }

        // LAS parser function
        function parseLAS(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            
            console.log('Parsing LAS header...');
            
            // Read LAS header signature
            const signature = String.fromCharCode(
                view.getUint8(0), 
                view.getUint8(1), 
                view.getUint8(2), 
                view.getUint8(3)
            );
            
            console.log('File signature:', signature);
            
            if (signature !== 'LASF') {
                throw new Error(`Not a valid LAS file. Signature: ${signature}`);
            }
            
            // Read version
            const versionMajor = view.getUint8(24);
            const versionMinor = view.getUint8(25);
            console.log(`LAS Version: ${versionMajor}.${versionMinor}`);
            
            // Header offsets
            const offsetToPointData = view.getUint32(96, true);
            const pointDataRecordLength = view.getUint16(105, true);
            const numberOfPointRecords = view.getUint32(107, true);
            
            console.log('Offset to point data:', offsetToPointData);
            console.log('Point data record length:', pointDataRecordLength);
            console.log('Number of point records:', numberOfPointRecords);
            
            // Scale and offset
            const xScale = view.getFloat64(131, true);
            const yScale = view.getFloat64(139, true);
            const zScale = view.getFloat64(147, true);
            const xOffset = view.getFloat64(155, true);
            const yOffset = view.getFloat64(163, true);
            const zOffset = view.getFloat64(171, true);
            
            console.log('Scale:', { x: xScale, y: yScale, z: zScale });
            console.log('Offset:', { x: xOffset, y: yOffset, z: zOffset });
            
            // Point data format
            const pointDataFormat = view.getUint8(104);
            console.log('Point data format:', pointDataFormat);
            
            const positions = [];
            const colors = [];
            
            // Sample to avoid browser crash on huge files
            const maxPoints = Math.min(numberOfPointRecords, 1000000);
            const step = Math.max(1, Math.floor(numberOfPointRecords / maxPoints));
            
            console.log(`Sampling every ${step} point(s), loading ${Math.floor(numberOfPointRecords / step)} points`);
            
            // Parse points
            for (let i = 0; i < numberOfPointRecords; i += step) {
                const offset = offsetToPointData + (i * pointDataRecordLength);
                
                // Read X, Y, Z
                const x = view.getInt32(offset, true) * xScale + xOffset;
                const y = view.getInt32(offset + 4, true) * yScale + yOffset;
                const z = view.getInt32(offset + 8, true) * zScale + zOffset;
                
                positions.push(x, y, z);
                
                // Read RGB if available
                if ([2, 3, 5, 7, 8, 10].includes(pointDataFormat)) {
                    const rgbOffset = pointDataFormat <= 3 ? 20 : 28;
                    const r = view.getUint16(offset + rgbOffset, true) / 65535;
                    const g = view.getUint16(offset + rgbOffset + 2, true) / 65535;
                    const b = view.getUint16(offset + rgbOffset + 4, true) / 65535;
                    colors.push(r, g, b);
                } else {
                    // Use intensity as grayscale
                    const intensity = view.getUint16(offset + 12, true) / 65535;
                    colors.push(intensity, intensity, intensity);
                }
            }
            
            console.log('Points loaded:', positions.length / 3);
            
            if (positions.length === 0) {
                throw new Error('No points were loaded from the file');
            }
            
            return { positions, colors };
        }

        // File upload functionality
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.las,.laz';
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const arrayBuffer = await file.arrayBuffer();
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Parsing LAS data...';
                
                try {
                    const lasData = parseLAS(arrayBuffer);
                    
                    // Clear existing point cloud
                    const existingCloud = scene.children.find(child => child instanceof THREE.Points);
                    if (existingCloud) scene.remove(existingCloud);
                    
                    // Create new point cloud
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(lasData.positions, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(lasData.colors, 3));
                    
                    const material = new THREE.PointsMaterial({
                        size: 3.0,
                        vertexColors: true,
                        sizeAttenuation: true
                    });
                    
                    const pointCloud = new THREE.Points(geometry, material);
                    scene.add(pointCloud);
                    
                    // Center camera
                    geometry.computeBoundingSphere();
                    const center = geometry.boundingSphere.center;
                    const radius = geometry.boundingSphere.radius;
                    
                    camera.position.set(center.x + radius, center.y + radius, center.z + radius);
                    controls.target.copy(center);
                    controls.update();
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('info').innerHTML = `
                        <strong>Point Cloud Info:</strong><br>
                        Points: ${(lasData.positions.length / 3).toLocaleString()}<br>
                        File: ${file.name}
                    `;
                } catch (error) {
                    showError(`Error parsing file: ${error.message}`);
                    document.getElementById('loading').style.display = 'none';
                }
            }
        });

        // Keyboard shortcut to open file
        window.addEventListener('keydown', (e) => {
            if (e.key === 'o' && e.ctrlKey) {
                e.preventDefault();
                fileInput.click();
            }
        });

        // Try loading from default paths
        const possiblePaths = [
            './BMT_Pointcloud%20segmented.las',
            './BMT_Pointcloud segmented.las',
            'BMT_Pointcloud%20segmented.las',
            'BMT_Pointcloud segmented.las'
        ];

        async function tryLoadFile() {
            for (const path of possiblePaths) {
                try {
                    console.log('Trying path:', path);
                    await loadLASFile(path);
                    return;
                } catch (error) {
                    console.log('Failed with path:', path);
                    continue;
                }
            }
            // If no file found, show instructions
            document.getElementById('loading').innerHTML = 
                'No point cloud found.<br>Press <span class="control-key">Ctrl + O</span> to load a .las file';
        }

        tryLoadFile();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>